# 基本语法



##  一、初识C

### 1. C语言标准

1978年 K&R C 传统C

1989年 ANSI C ==> C89 

1990年 ISO C ==> C90 与C89相同

  C精神:

1. 信任程序员
2. 不要妨碍程序员做需要做的事
3. 保持语言精练简单
4. 只提供一种方法执行一项操作
5. 让程序运行更快，即使不能保证其可移植性

1994年 ANSI/ISO ==> C99

新目标：国际化、弥补缺陷和提高计算的实用性

2011年 ISO  ==> C11

2018年  ISO  ==> C17

c语言标准委员会地址:[[Project status and milestones (open-std.org)](http://www.open-std.org/JTC1/SC22/WG14/www/projects#9899)]

标准文档(pdf)下载：
 [C99标准文档](http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf)   [C11标准文档](http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf)   [C17标准文档](http://www.open-std.org/JTC1/SC22/WG14/www/docs/n2310.pdf)   [C2x标准文档](http://www.open-std.org/JTC1/SC22/WG14/www/docs/n2596.pdf)



主要学习 C89/90  用C99或C11介绍新特性

[visual studio C标准库文档](https://docs.microsoft.com/cpp/c-runtime-library/reference/crt-alphabetical-function-reference)

[C语言帮助文档](https://docs.microsoft.com/cpp/c-language/)

### 2.编译过程

**Linux**:

c语言编译过程：

1. 预处理(Preprocessing)
       展开头文件/宏替换/去掉注释/条件编译 (.i)

2. 编译(Compilation)
       检查语法，生成汇编代码 (.s)

3. 汇编(Assembly)
       汇编代码转换机器码    (.o)

4. 链接(Linking)
       链接到一起生成可执行程序    (.out .a .so)

**Windows**:

源代码(.c) --> 编译器  --> 目标代码(.obj) --> 连接器+库代码+启动代码 --> 可执行代码(.exe,.dll)

 

## 二、Hello World

### 1. 代码

[2_1_first.c](src/2_1_first.c) :

```c
#include <stdio.h> //引入文件头

int main(void) /* 函数头: 返回类型 函数名(参数[这里是void]) */
{
    printf("Hello world!\n"); //调用stdio标准库里的printf函数, \n是换行符

    int x; /* 定义一个名为x的变量 */
    x = 1; /* 为x赋一个值 */ 
    printf("x=%d\n",x); //再次调用stdio标准库里的printf函数，并传参数
    return 0; //返回一个数
}
```

### 2. 编译&运行

自己写了个脚本([compileOneAndRun.bat](compileOneAndRun.bat))来编译执行这个程序：

![2-1-compileAndRun.png](img/2-1-compileAndRun.png)

### 3.注意

1. 每次用到库函数，都会用#include指令包含ANSI/ISO标准指定的头文件
2. main函数必须加(void),返回值必须是int



## 三、数据类型

关键字：int、short、long、unsigned、char、float、double、_Bool、_Complex、_Imaginary
运算符：sizeof()
函数：scanf()



C语言数据类型关键字：

| K&R C    | C90    | C99               |
| -------- | ------ | ----------------- |
| int      | signed | _Bool(true/false) |
| long     | void   | _Complex(复数)    |
| unsigned |        | _Imaginary(虚数)  |
| char     |        |                   |
| float    |        |                   |
| double   |        |                   |

### 1. 整数

   > 1. 声明变量   int a,b,c;
   >
   > 2. 初始化变量  int i=1,j=2;
   >
   > 3. printf int占位符%d  
   >
   >    如：printf("%d",i) 
   >
   >    示例：[3_1_platinum.c](src/3_1_platinum.c)
   >
   > 4. 字面量：
   >
   >    十进制  7,    8,  9,   10,  15,  16
   >
   >    八进制  07,  10, 11, 12,  17, 20 
   >
   >    十六进制  0x7, 0X8 , 0x9, 0XA, 0XF, 0x10
   >
   >    printf 显示八进制占位符： %o ,带0前缀 %#o
   >
   >     printf 显示十六进制占位符： %x ,  %X,  带0x前缀 %#x,%#X
   >    
   >    示例：[3_2_int_Literal.c](src/3_2_int_Literal.c)

### 2. 整数其他形式

   > 附属关键字 short long unsigned
   >
   > short int 或 short
   >
   > long int 或 long
   >
   > long long int或long long 至少64bit
   >
   > unsigned int 或 unsigned 无符号整数(非负)
   >
   > unsigned short ,  unsigned long , unsigned long long
   >
   > 任何有符号类型前添加关键字signed可以强调有符号(有负数)， 如 signed int 等同于 int
   >
   > 
   >
   > c语言规定 
   >
   > short占用空间不能比int多 ，long占用空间不能比int少
   >
   > 现在个人计算机常见设置：long long - 64bit, long 32bit, short 16bit, int 16bit或32bit(依计算机自然字长而定)
   >
   > 
   >
   > long和long long字面常量
   >
   > 数字字面量后加L或l,
   >
   > 在支持long long类型的系统中，也可以使用ll或LL后缀表示long long类型，u或U后缀表示无符号，如5ull,5Ull,5llU,5LLu
   >
   > 
   >
   > printf中unsigned 用%u前缀，short用%h前缀，long用%l前缀，long long用%ll前缀
   >
   > 示例[3_3_more_int.c](src/3_3_more_int.c)
   >
   > 
   >
   > 整数运算溢出时，从整数类型能表示最小值开始计算
   >
   > 
   >
   > char类型-1字节
   >
   > 字符'j'  '\x6A' '\0152'
   >
   > printf 占位符%c
   >
   > 有些C编译器把char实现为有符号类型，这意味着char可表示的范围是-128～127。而有些C编译器把char实现为无符号类型
   >
   > C90: 
   >
   > unsigned char表示无符号字节字符
   >
   > signed char表示有符号字节字符
   >
   > 
   >
   > `_Bool`类型
   > C99标准添加了`_Bool`类型，用于表示布尔值，即逻辑值true和false。因为C语言用值1表示true，值0表示false，所以`_Bool`类型实际上也是一种整数类型。但原则上它仅占用1位存储空间，因为对0和1而言，1位的存储空间足够了
   >
   > 
   >
   > C99可移植类型
   >
   > ​	stdint.h和inttypes.h
   >
   > int8_t~int64_t， uint8_t ~ uint64_t
   >
   > int_least8_t uint_least8_t
   >
   > int_fast8_t uint_fast8_t
   >
   > 
   >
   > intmax_t uintmax_t
   >
   > 

### 3. 浮点型

   >float、double和long double
   >
   >浮点字面量：
   >
   >有符号的数字(包括小数点)，后面紧跟e或E，最后是一个有符号数表示10的指数
   >
   >​	正号可以省略。可以没有小数点(如，2E5)或指数部分(如，19.28)，但是不能同时省略两者。
   >
   >可以省略小数部分(如，3.E16)或整数部分(如，.45E-6)，但是不能同时省略两者。
   >
   >
   >
   >C99 标准添加了一种新的浮点型常量格式——用十六进制表示浮点型常量，即在十六进制数前加上十六进制前缀(0x或0X)，用p和P分别代替e和E，用2的幂代替10的幂(即，p计数法)。如下所示：
   >0xa.1fp10
   >
   >
   >
   >printf()函数使用％f转换说明打印十进制记数法的float和double类型浮点数，用％e打印指数记数法的浮点数。如果系统支持十六进制格式的浮点数，可用a和A分别代替e和E。打印long double类型要使用％Lf、％Le或％La转换说明
   >
   >
   >
   >IEEE浮点标准,在C11作为可选项
   >
   >

### 4. 复数

   > 一般而言，虚数类型都是可选项。C11标准把整个复数软件包都作为可选项
   >
   > 
   >
   > C语言有3种复数类型：`float_Complex`、`double_Complex`和`long double _Complex`。例如，`float _Complex`类型的变量应包含两个float类型的值，分别表示复数的实部和虚部。
   >
   > 
   >
   > 类似地，C语言的3种虚数类型是float _Imaginary、`double _Imaginary`和`long double _Imaginary`。
   >
   > 
   >
   > 如果包含complex.h头文件，便可用complex代替`_Complex`，用imaginary代替`_Imaginary`，还可以用I代替-1的平方根。

### 5. 其他类型

   > C语言还有一些从基本类型衍生的其他类型，包括数组、指针、结构和联合

### 6. 类型大小

   > sizeof是C语言的内置运算符，以字节为单位给出指定类型的大小
   >
   > 
   >
   > C99和C11提供％zd转换说明匹配sizeof的返回类型(size_t)
   >
   > 示例：[3_4_sizeof.c](src/3_4_sizeof.c)

### 7. 转义字符

   > 警报声(\a) 退格(\b)、水平制表符(\t)和回车(\t)
   >
   > 示例[3_5_escape.c](src/3_5_escape.c)



## 四、字符串

### 1.  介绍字符串

> 字符数组，末尾加'\0' (null 字符)
>
> 注意：只能输入ANSI字符，why?因为需要支持'\0'字符结尾
>
> 示例:[4_1_string_intro.c](src/4_1_string_intro.c)
>
> C99 和 C11 标准专门为 sizeof 运算符的返回类型添加了％zd 转换说明
>
> scanf安全性不够，C4996提示用scanf_s



### 2. 预处理器 

   > #define NAME value
   >
   > 常量限定符 const(定义只读变量)
   >
   > limits.sh和float.h数据范围常量
   >
   > CHAR_MIN SHRT_MIN INT_MIN UINT_MIN ULONG_MIN FLT_MIN DBL_MIN
   >
   > CHAR_MAX SHRT_MAX INT_MAX UINT_MAX ULONG_MAX FLT_MAX DBL_MAX



### 3. printf & scanf

> 1. printf-转换说明符(conversion specification)
>
> 浮点数  -- 16进制和p计数法：%a、%A     10进制:%f   e计数法：%e,%E  自动匹配%g %G
> 单字符  --  %c
> 字符串  --  %s
> 有符号10进制整数  --   %d、%i
> 无符号10进制整数  --   %u
> 无符号8进制整数  --   %o
> 无符号16进制整数  --   %X、%x
> 指针  -- %p
>
> 2. printf-转换修饰符
>
>    ![4-3-Conversion-Spec-Modifier.png](img/4-3-Conversion-Spec-Modifier.png)
>
> 3. scanf
>
>    scanf()函数允许把普通字符放在格式字符串中
>
>    如：`scanf("％d,％d", &n, &m);` 必须输入逗号"," 但可以跳过空格
>
>    scanf()函数返回成功读取的项数。
>    没有读到或没有正确正确读取时scanf()返回0。
>    当scanf()检测到“文件结尾”时，会返回EOF
>
>    scanf("％c",num)会读取每个字符，包括空格
>
> 4. 如果你不想预先指定字段宽度，希望通过程序来指定，那么可以用`*`修饰符代替字段宽度。
>
>    但还是要用一个参数告诉函数，字段宽度应该是多少。
>
>    如`printf("The number is: ％*d.\n", width, number);`
>
>    scanf()中`*`的用法与此不同。把*放在％和转换字符之间时，会使得scanf()跳过相应的输出项



## 五、运算符

### 1.循环

> while (*condition*) { }
>
> 示例 [5_1_shoe_size.c](src/5_1_shoe_size.c)

### 2.运算符operator

> 赋值运算=
>
> 术语：数据对象、左值、右值和运算符
>
> 用于储存值的数据存储区域统称为**数据对象(data object)**
>
> **左值(lvalue)**是 C 语言的术语，用于标识特定数据对象的名称或表达式。因此，对象指的是实际的数据存储，而左值是用于标识或定位存储位置的标签。
>
> ​	可修改的左值(modifiable lvalue)，用于标识可修改的对象。
>
> ​    所以，赋值运算符的左侧应该是可修改的左值。当前标准建议，使用术语对象定位值(object locator value)更好
>
> 可以多重赋值：a=b=c=1;(赋值表达式 返回的结果就是被赋的值)
>
> 
>
> 算术运算符：加+、减-、乘*、除/
>
> 运算符优先级 ：
>
> 1. 小括号()最优先 ，从左往右结合
>
> 2. 正+负-号 (一元运算)
>
> 3. 乘除
>
> 4. 加+减-
>
> 5. 赋值=
>
> sizeof运算符 返回size_t类型
> 求模运算符 %
> 递增运算++
> 递减运算--
>
> 
>

### 3.表达式+语句

> 术语：
>
> **表达式(expression)**由运算符和运算对象组成
>
> 每个表达式都有一个值
>
> **语句(statement)**
>
> 语句(statement)是C程序的基本构建块。一条语句相当于一条完整的计算机指令。在C中，大部分语句都以分号结尾
>
> 例：赋值表达式语句的结构是，一个变量名，后面是一个赋值运算符，再跟着一个表达式，最后以分号结尾
>
> while语句是一种迭代语句，有时也被称为结构化语句，因为它的结构比简单的赋值表达式语句复杂
>
> 
>
> **副作用(side effect)**是对数据对象或文件的修改
>
> 完整表达式(full expression)，就是指这个表达式不是另一个更大表达式的子表达式
>
> **序列点(sequence point)**是程序执行的点，在该点上，所有的副作用都在进入下一步之前发生。在 C语言中，语句中的分号标记了一个序列点。意思是，在一个语句中，赋值运算符、递增运算符和递减运算符对运算对象做的改变必须在程序执行下一条语句之前完成。
>
> **复合语句(compound statement)**是用花括号括起来的一条或多条语句，复合语句也称为块(block)。
>
> 

### 4.类型转换

> 基本的类型转换规则:
>
> 1. 当类型转换出现在表达式时，从较小类型转换为较大类型，所以这些转换被称为升级(promotion)
> 2. 涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别
> 3. 类型的级别从高至低依次是long double、double、float、unsigned long long、long long、unsigned long、long、unsigned int、int
> 4. 在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。这个过程可能导致类型升级或降级(demotion)。所谓降级，是指把一种类型转换成更低级别的类型。
> 5. 当作为函数参数传递时，char和short被转换成int，float被转换成double。
>
> 降级处理：
>
> 1. 目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略
>
> 2. 如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异。
> 3.  如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的。
>
> 
>
>  强制类型转换运算符:
>
> 圆括号和它括起来的类型名构成了强制类型转换运算符(cast operator)
>
> 如：int a=(int)1.5;

### 5.带参数的函数

> 声明参数就创建了被称为形式参数(简称形参)的变量
>
> 函数调用传递的值为实际参数，简称实参
>
> 是C99标准规定 :实参术语actual  argument;  形参术语formal parameter
>
> 示例[5_2_func_param.c](src/5_2_func_param.c)
>
> **函数声明**只指明了函数名和返回类型，没有指明参数类型
>
> **函数原型**在函数声明的基础上包含形参。

### 6.运算符优先级

> ![5-6-operator-precedence.png](img/5-6-operator-precedence.png)
> 
>
> 

## 六、循环语句

### 1. while循环

> while( expression) 
>
> { statement }
>
> 入口条件循环entry condition

### 2. 条件运算符

   > < > == != >= <=
   >
   > 
   >
   > 一般而言，所有的非零值都视为真，只有0被视为假
   >
   > 
   >
   > C一直用int类型的变量表示真/假值。C99专门针对这种类型的变量新增了_Bool类型
   >
   > C99提供了stdbool.h头文件，该头文件让bool成为_Bool的别名，而且还把true和false分别定义为1和0的符号常量
   >

### 3. for循环

> while循环是不确定循环(indefinite loop)。所谓不确定循环，指在测试表达式为假之前，预先不知道要执行多少次循环。
>
> 还有一类是计数循环(counting loop)。这类循环在执行循环之前就知道要重复执行多少次。
>
> for循环语法：
>
> for　(　initialize;　test;　update　)
> 　　statement

### 4. 其他运算符

> 其他赋值运算符：+=、-=、*=、/=、％=
>
> **逗号运算符**扩展了for循环的灵活性，以便在循环头中包含更多的表达式

### 5. do while循环

> while循环和for循环都是入口条件循环，即在循环的每次迭代之前检查测试条件，所以有可能根本不执行循环体中的内容。
>
> C语言还有出口条件循环(exit-condition loop)，即在循环的每次迭代之后检查测试条件，这保证了至少执行循环体中的内容一次。
>
> 如 do while循环，语法：
>
> do{
> 　　statement;
> }while　(　expression　);

### 6.循环与数组

> 数组(array)是按顺序储存的一系列类型相同的值,。整个数组有一个数组名，通过整数下标访问数组中单独的项或元素(element)
>
> char类型的数组末尾包含一个表示字符串末尾的空字符\0，则该数组中的内容就构成了一个字符串
>
> ~~~c
> int nums[22]; // 可储存10个int类型的数组
> char str[]={'h','e','l','l','o','\0'}; //char数组，因为末尾有0,所以也是一个字符串
> ~~~
>
> 循环遍历数组：[6_1_for_loop_array.c](src/6_1_for_loop_array.c)



## 七、分支&跳转

### 1.判断if else

> if语句被称为分支语句(branching statement)或选择语句(selection statement)，因为它相当于一个交叉点，程序要在两条分支中选择一条执行。if语句的通用形式如下：
> `if ( expression ) { statement }`
>
> 
>
> if else语句的通用形式是：
>
> ```c
> if ( expression ) { statement }
> else { statement3} 
> ```
>
> 
>
> 
>
> 多重if else 
>
> ```c
> if ( expression1 ) { statement1} 
> else if ( expression2 ) { statement2} 
> else if ( expression3 ) { statement3} 
> else if ( expression4 ) { statement4} 
> ...
> else { statementN} 
> ```
>
> 
>
> 
>
> <stdio.h>中：
>
> getchar() 从输入队列中返回下一个字符
>
> putchar(char) 输出一个字符到显示器
>
> < ctype.h>中有字符判断函数:如isalpha(char), isblank(char), isdigit(char) isspace(char)  islower(char) issupper(char)等等
>
> 示例:[7_1_change_input.c](src/7_1_change_input.c)

### 2. 逻辑运算符

> 与&&  或|| 非 !
>
> 引入<iso646.h>(C95)可以用备选拼写
>
> && 对应 and ， || 对应 or  ， ! 对应 not

### 3. 条件运算符

> 又称三元运算符或三目运算符
>
> `expression1 ? expression2：expression3`
>
> 如果 expression1 为真(非 0)，那么整个条件表达式的值与 expression2 的值相同；如果expression1为假(0)，那么整个条件表达式的值与expression3的值相同
>
> 如求最大值：
>
> `max = (a > b) ? a：b;`

### 4. continue & break

> 3种循环都可以使用continue语句。执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代。如果continue语句在嵌套循环内，则只会影响包含该语句的内层循环
>
> 程序执行到循环中的break语句时，会终止包含它的循环，并继续执行下一阶段。如果break语句位于嵌套循环内，它只会影响包含它的当前循环。
>
> ![7-4-continue&break.png](img/7-4-continue&break.png)

### 5. switch+break

> 
> 语法:
> ```c
> switch ( 整型表达式)
> {
> 　　case 常量1：
> 　　　　语句　　　//可选
> 　　　　break;  //可选
> 　　case 常量2：
> 　　　　语句　　　//可选
> 　　　　break;  //可选
> 　　default：　　 //可选
> 　　　　语句　　　//可选
> 　　　　break;  //可选
> }
> ```
>

### 6. goto语句
> goto语句有两部分：goto和标签名。标签的命名遵循变量命名规则，如下所示：
> `goto part2;`
> 要让这条语句正常工作，函数还必须包含另一条标为part2的语句，该语句以标签名后紧跟一个冒号开始：
> `part2：printf("xxx");`
>
> **避免使用goto**

### 7. 字符操作、io流

> 缓冲区
>
> 大部分系统在用户按下Enter键之前不会重复打印刚输入的字符，这种输入形式属于缓冲输入。用户输入的字符被收集并储存在一个被称为缓冲区(buffer)的临时存储区，按下Enter键后，程序才可使用用户输入的字符
>
>  某些交互式程序也需要无缓冲输入。例如，在游戏中，你希望按下一个键就执行相应的指令
>
> 
>
> 可以用处理文件的方式来处理键盘输入。例如，程序读文件时要能检测文件的末尾才知道应在何处停止。因此，C 的输入函数内置了文件结尾检测器。既然可以把键盘输入视为文件，那么也应该能使用文件结尾检测器结束键盘输入
>
> 检测文件结尾的一种方法是，在文件末尾放一个特殊的字符标记文件结尾。CP/M、IBM-DOS和MS-DOS的文本文件曾经用过这种方法。
>
> 在C语言中，用getchar()读取文件检测到文件结尾时将返回一个特殊的值，即EOF(end of file的缩写，定义在stdio.h文件)。scanf()函数检测到文件结尾时也返回EOF
>
> 
>
> 字符操作：[7_1_char_get_put.c](src/7_1_char_get_put.c)
>
> 编译产生可执行文件：7_1_char_get_put.exe
>
> 1. 重定向输入，将my.txt文件的内容输出屏幕上:
>
>    `7_1_char_get_put.exe<my.txt`
>
> 2. 重定向输出，接收键盘输入，输出到my.txt文件
>
>    `7_1_char_get_put.exe>my.txt`
>
> 3. 组合重定向，复制my.txt到target.txt
>
>    `7_1_char_get_put.exe<my.txt>target.txt`
>
> 



## 八、函数

### 1.概念

> 函数是完成特定任务的独立程序代码单元
>
> 功能: 执行动作，返回值
>
> 
>
> **函数原型(function prototype)**告诉编译器函数名，函数的参数、返回类型。
>
> ​	函数的返回类型和形参列表构成了**函数签名(signature)**；
>
> **函数调用(function call)**表明在此处执行函数；
>
> **函数定义(function definition)**明确地指定了函数要做什么
>
> 
>
> 区分形参与实参
>
> 实际参数是出现在函数调用圆括号中的表达式。形式参数是函数定义的函数头中声明的变量。调用函数时，创建了声明为形式参数的变量并初始化为实际参数的求值结果
>
> 
>
> 声明函数时必须声明函数的类型。带返回值的函数类型应该与其返回值类型相同，而没有返回值的函数应声明为void类型。如果没有声明函数的类型，旧版本的C编译器会假定函数的类型是int。这一惯例源于C的早期，那时的函数绝大多数都是int类型。然而，C99标准不再支持int类型函数的这种假定设置。
> 类型声明是函数定义的一部分。要记住，函数类型指的是返回值的类型，不是函数参数的类型
>
> 示例:[8_1_func_type.c](scr/8_1_func_type.c)
>
> 
>
> 要正确地使用函数，程序在第 1 次使用函数之前必须知道函数的类型。方法之一是，把完整的函数定义放在第1次调用函数的前面。然而，这种方法增加了程序的阅读难度。而且，要使用的函数可能在C库或其他文件中。因此，通常的做法是提前声明函数，把函数的信息告知编译器。
>
> 
>
> 主调函数把它的参数储存在被称为栈(stack)的临时存储区，被调函数从栈中读取这些参数。
>
> 不定参函数：
>
> int printf(const char *, ...)
>
> 
>
> **递归**：允许函数调用它自己
>
> 优点是递归为某些编程问题提供了最简单的解决方案。
>
> 缺点是一些递归算法会快速消耗计算机的内存资源
>
> 示例：[8_2_fibonacci.c](src/8_2_fibonacci.c)
>
> 

### 2.  编译多源代码

> cl.exe可以使用@source-list.txt的形式引用多个文件
>
> /I设置include头文件，或放到c源文件同目录
>
> #include预编译指令，搜索.h文件顺序：
> 1.绝对路径直接按绝对路径搜索
> 2.相对路径：
>  1.对于双引号的(本地优先)：
>      1.先到当前c文件目录搜索
>      2.再到之前打开过的include文件的目录搜索
>      3.在编译器设置的路径搜索(/I选项)
>      4.在系统的INCLUDE环境变量内搜索
>  2.队列用尖括号的(设置路径优先)：
>      1.在编译器设置的路径搜索(/I选项)
>      2.在系统的INCLUDE环境变量内搜索
>
> 示例:
> [8_3_add.h](include/8_3_add.h) 、[8_3_add_impl.c](src/8_3_add_impl.c)
> [8_3_star.h](include/8_3_star.h)  、[8_3_star_impl.c](src/8_3_star_impl.c)
> [8_3_include.h](src/8_3_include.h)、[8_3_compile_more.c](src/8_3_compile_more.c)
>
> 多文件编译脚本:[compileMoreAndRun.bat](compileMoreAndRun.bat)
>
> 

### 3. 指针初始

   > 指针(pointer)是 C 语言最重要的(有时也是最复杂的)概念之一，用于储存变量的地址
   >
   > 一元**&运算符**给出变量的存储地址。如果var是变量名，那么&var是变量的地址。可以把地址看作是变量在内存中的位置。
   >
   > 后跟一个变量名时，&给出该变量的地址。
   >
   > 
   >
   > 指针？什么是指针？从根本上看，指针(pointer)是一个值为内存地址的变量(或数据对象)
   >
   > 用间接**运算符***(indirection operator)
   >
   > 后跟一个指针名或地址时，*给出储存在指针指向地址上的值。
   >
   > 
   >
   > 声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间
   >
   > ```c
   > int * pi; //pi是指向int类型变量的指针
   > char * pc; //pc是指向char型变量的指针
   > ```
   >
   > *和指针名之间的空格可有可无。通常，程序员在声明时使用空格，在解引用变量时省略空格。
   >
   > 
   >
   > pc指向的值(*pc)是char类型。pc本身是什么类型？我们描述它的类型是“指向char类型的指针”。
   >
   > pc 的值是一个地址，在大部分系统内部，该地址由一个无符号整数表示。但是，不要把指针认为是整数类型。一些处理整数的操作不能用来处理指针，反之亦然。
   >
   > 示例[8_4_pointer_intro.c](src/8_4_pointer_intro.c)
   >
   > 



## 九、数组和指针

### 1.数组

> 通过声明数组告诉编译器数组中内含多少元素和这些元素的类型
>
> 
>
> 只储存单个值的变量有时也称为标量变量(scalar variable)，我们已经很熟悉如何初始化这种变量：
> `int　fix　=　1;`
> `float flax = PI * 2;`
>
>  
>
> 以逗号分隔的值列表(用花括号括起来)来初始化数组，各值之间用逗号分隔
>
> `int arr[4] = {1，2，3，4};`
>
>  
>
> 注意 使用const声明数组
>
> 有时需要把数组设置为只读。这样，程序只能从数组中检索值，不能把新值写入数组。
>
> `const int arr[4] = {1，2，3，4};`
>
>  
>
> 数组自动存储类别，意思是这些数组在函数内部声明，且声明时未使用关键字static
>
> 当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为0。也就是说，如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都是垃圾值；但是，如果部分初始化数组，剩余的元素就会被初始化为0
>
> 声明数组后，可以借助数组下标(或索引)给数组元素赋值
>
>
> C99 增加了一个新特性：指定初始化器(designated initializer)。利用该特性可以初始化指定的数组元素:
>
> ```c
> int arr[8]={0,0,0,0,0,0,123,0};//以前的赋值方法
> int arr[8]={[6]=212}//而C99规定，可以在初始化列表中使用带方括号的下标指明待初始化的元素
> arr[7=123;//根据索引赋值
> ```
>
> 示例：[9_1_designated.c](src/9_1_designated.c)
>
> 
>
> 在使用数组时，要防止数组下标超出边界,c语言不会检查边界
>
> 在C99标准之前，声明数组时只能在方括号中使用整型常量表达式。所谓整型常量表达式，是由整型常量构成的表达式。sizeof表达式被视为整型常量，但是(与C++不同)const值不是。另外，表达式的值必须大于0
>
> 
>
> 而C99标准允许这样声明，这创建了一种新型数组，称为变长数组(variable-length array)或简称 VLA(C11 放弃了这一创新的举措，把VLA设定为可选，而不是语言必备的特性)。
>
> 

### 2.多维数组

> 1. 说明：
>
>    一维数组：
>
>    ​	`type arr[SIZE1]={1,..};` //声明+初始化
>
>    ​	`type a=arr[index1]; `//从数组中取元素
>
>    ​    `arr[index1]=a;`/存储元素到数组
>
>    二维数组：
>
>    ​	`type arr[SIZE1][SIZE2]={{1,..},{2,..}};` //声明+初始化
>
>    ​	`type a=arr[index1][index2]; `//从数组中取元素
>
>    ​    `arr[index][index2]=a;`//存储元素到数组
>
>    N维数组： 
>
>    ​	`type arr[SIZE1][SIZE2]...[SIZE-N]={{...{1,..}...},...,{...{2,..}...}};` //声明+初始化
>
>    ​	`type a=arr[index1][index2]...[indexN]; `//从数组中取元素
>
>    ​    `arr[index1][index2]...[indexN]=a;`//存储元素到数组
>
>    N数组可以看作`SIZE1*SIZE2**...*SIZE-N`个元素的一维type类型数组或`type*`指针,所以可以按一维数组的初始化来初始化数据
>
> 2. 初始化：
>
> 初始化二维数组是建立在初始化一维数组的基础上
>
> 如一维数组是：`typex arr[2]={x1,x2}; `
>
> 假设typex是包含3个int的数组，那么相应二维数组表示为：
>
> `int arr[2][3]={{1,2,3},{4,5,6}}`
>
> 初始化时也可省略内部的花括号，只保留最外面的一对花括号。只要保证初始化的数值个数正确，初始化的效果与上面相同。但是如果初始化的数值不够，则按照先后顺序逐行初始化，直到用完所有的值
>
> 2. 同理可以声明多维数组
>
>    `int arr[1][2][3]`
>    
>    
>
> 

### 3.指针

> 指针提供一种以符号形式使用地址的方法
>
> 数组名是数组首元素的地址,
>
> ，如果arr是一个数组，下面的语句成立：
>
> ```c
> int arr[4];
> arr == &arr[0]; // 数组名是该数组首元素的地址
> ```
>
> 
>
> 指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的硬件。许多计算机(包括PC和Macintosh)都是按字节编址，意思是内存中的每个字节都按顺序编号。这里，一个较大对象的地址(如double类型的变量)通常是该对象第一个字节的地址。
> 在指针前面使用*运算符可以得到该指针所指向对象的值。
>
> 例：[9_3_pointer_add.c](src/9_3_pointer_add.c)

### 4.函数+数组+指针

> 1.指针参数：[9_4_pointer_as_param.c](src/9_4_pointer_as_param.c)
>
> 2.指针运算优先级：
>
> ​	一元运算符*和++的优先级相同，但结合律是从右往左
>
> `*p++`  指针先递增 后取递增前的指针的值 等同于 `*(p++)`
>
> `*++p`  指针先递增 后取递增后的指针的值 等同于 `*(p++)`
>
> `(*p)++` 先取指针的值 后对值递增,表达式结果为递增前的值
>
> `++*p`  先取指针的值 后对值递增 ,表达式结果为递增后的值 等同于 `++(*p)`
>
> 
>
> &arr[3] 取数组arr第三个元素的地址
>
> 
>
> 数组变量与指针变量大多时候等价，但数组变量不能为左值,即一下代码会编译报错：
>
> ```c
> int arr[];
> arr++;//报错：error C2105: '++' needs l-value
> ```
>
> 

### 5.指针操作

> 1. 赋值 
>
>    把一个递增赋值给指针变量
>
>    `int i=0; int *p=&i;`
>
> 2. 解引用指针(*p)
>
>    `i==*p` 注意：不要解引用未初始化的指针
>
> 3. 获得指针的地址(&p)
>
>    `int **pp=&p;` 注意：不能对**符号常量**和**字面常量**取址
>
> 4. 指针加减法
>
>    `p++;p--;p+=2;p-=2;p=p+3;p=p-3;`
>
> 5. 两个指针求差
>
>    连个同类型指针的差为相差的类型的个数。
>
>    例:[9_5_ptr_diff.c](src/9_5_ptr_diff.c)

### 6.const

> 1. 对形式参数使用const
>
>    如果函数的意图不是修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字const
>
>    使用const并不是要求原数组是常量，而是该函数在处理数组时将其视为常量，不可更改
>
>    虽然用#define指令可以创建类似功能的符号常量，
>
>    但是const的用法更加灵活。可以创建**const数组**、**const指针**和**指向const的指针**。
>
> 2. 用法：
>
>    ```c
>    int i1=0;//i是变量，可以修改，可以赋值给常量
>    const int i2=i1; //i是整数常量(不能修改值),可以赋值给变量，不能赋值给非初始化的常量
>                            
>    //存储整数变量的数组，数组中元素可以修改,但数组地址arr初始化后不能被修改，可给同类型数组初始化，可给同类型指针变量赋值或初始化，不能赋值给指针常量与数组
>    int arr1[]={1,2,3}; 
>    //存储整数常量的数组，数组中元素不能修改，arr初始化后不能被修改，可给同类型数组初始化，初始化或赋值给指针变量时告警，不能赋值给指针常量与数组
>    const int arr2[]={1,2,3}; 
>                            
>    int * const cptr1={1,2,3}; //指向整数常量的指针常量 同整型变量数组
>    const int * const cptr2={1,2,3}; //指向整数常量的指针常量 同整型常量数组
>                            
>    int *vptr1=arr1;//指向整数变量的指针变量，指针地址值可变
>    int *const vptr2=arr1;//指向整数变量的指针变量，指针地址值可变
>    ```
>
>    **注意：**const定义**不能修改的变量** 或**声明型常量**
>
>    所以：
>
>    1.数组变量 等同于  指针常量 ，如： ` int arr[]` <==> `int * const cptr`
>
>    2.可以在指针上用取元素操作，但不能在数组上用赋值或递增减操作，如 对： `cptr[0]`   错:`arr++`;
>
>    

### 7.多维数组+指针

> 指针,由于`[]运算符`优先级高于`*运算符`，所以：
>
> `type (*ptr) [N];`  //ptr是指向一个内含N个type类型值的数组的**指针**
>
> `type *pArr [N];`//pArr是一个包含N个`type *`类型元素的**数组**
>
>  例:[9_7_ptr_multi-d_array.c](src/9_7_ptr_multi-d_array.c)
>
> 不同类型的指针不能赋值
>
> 
>
> 多维数组形参声明：
>
> ```c
> //1.一个指向数组(内含4个int类型值)的指针。可以这样声明函数的形参:
> void somefunction1( int (* pt)[4] );
> //2.另外，如果当且仅当pt是一个函数的形式参数时，可以这样声明：
> void somefunction2( int pt[][4] );
> //3.也可以在第1对方括号中写上大小，如下所示，但是编译器会忽略该值：
> int somefunction3(int ar[3][4]， int rows); 
> //4.1.一般而言，声明一个指向N维数组的指针时，只能省略最左边方括号中的值：
> int somefunction4(int ar[][12][20][30], int rows);
> //4.2.因为第1对方括号只用于表明这是一个指针，而其他的方括号则用于描述指针所指向数据对象的类型。下面的声明与该声明等价：
> int somefunction4(int (*ar)[12][20][30],int rows); 
> ```
>
> 

### 8.变长数组

> 是C99/C11允许使用整型非常量表达式来初始化数组大小。这种情况下的数组被称为变长数组(variable-length array，VLA)，C99新增特性，需要编译参数开启
>
> 注意 变长数组不能改变大小
> 变长数组中的“变”不是指可以修改已创建数组的大小。一旦创建了变长数组，它的大小则保持不变。这里的“变”指的是：在创建数组时，可以使用变量指定数组的维度。
>
> ```c
>  //C99/C11 VLA函数原型：ar是一个变长数组(VLA)，省略了维度形参名
> int sum2d(int， int， int ar[*][*]);
> //该函数的定义如下：
> int　sum2d(int　rows，　int　cols，　int　ar[rows][cols]){
>     ...
>     return 0;
> }
> ```
>
> 
>
> visual studio貌似不支持
>
> 略过...

### 9.复合字面量

> C99新增了复合字面量(compound literal)。字面量是除符号常量外的常量。
>
> 对于数组，复合字面量类似数组初始化列表，前面是用括号括起来的类型名。例如，下面是一个普通的数组声明：
> int diva[2] = {10， 20};
> 下面的复合字面量创建了一个和diva数组相同的匿名数组，也有两个int类型的值：
> (int [2]){10， 20}　　　// 复合字面量
>
> 例：[9_8_compound_literal.c](src/9_8_compound_literal.c)
>
> 

## 十、字符串

### 1.字符串定义 

> 字符串是以空字符(\0)结尾的char类型数组
>
> 定义方法：
>
> 1.字符串字面量(字符串常量)
>
> ​    用双引号括起来的内容称为字符串字面量(string literal)，也叫作字符串常量(string constant)
>
> ​    双引号中的字符和编译器自动加入末尾的\0字符，都作为字符串储存在内存中
>
> ​    用双引号括起来的内容被视为指向该字符串储存位置的指针
>
> ​    从ANSI C标准起，如果字符串字面量之间没有间隔，或者用空白字符分隔，C会将其视为串联起来的字符串字面量。
>
> ​    字符串常量属于静态存储类别(static storage class); 在函数中使用字符串常量，即使函数被调用多次,字符串也只会被储存一次
>
> 
>
> 2.字符串数组和初始化
>
> ```c
> char str1[]={'h','e','l','l','o','\0'};//注意最后的空字符。没有这个空字符，这就不是一个字符串，而是一个字符数组。
> const char str2[10]="hello";//数组长度要大于字符串长度
> const char str3[]="hello";//编译器自动计算数组长度
> str3 == &str3[0];//表达式为真
> *str3 == 'h';//表达式为真
> str3[1] == 'e';//表达式为真
> *(str3+1) == 'e';//表达式为真
> const char *str4="hello";//字符串字面量初始化指针
> ```
>
> 在C99新增变长数组之前，数组的大小必须是整型常量，包括由整型常量组成的表达式
>
> **注意：**初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针
>
> 示例:[10_1_string_define.c](src/10_1_string_define.c)
>
> puts()函数只显示字符串，而且自动在显示的字符串末尾加上换行符。也由<stdio.h>引入
>
> 
>
> 3.字符串数组
>
> 两种方法：
>
> 1.字符指针数组  或 指向指针的指针  
>
> ​	数组元素为指针，长度为  数组个数*指针占用长度，注意：指针数组最好不要修改，
>
> 2.字符数组的数组 
>
> ​	数组元素为字符数组，长度为 总数组个数* 字符数组长度
>
> 示例：[10_2_string_s_array.c](src/10_2_string_s_array.c)
>
> 

### 2. 字符串输入

> 如果想把一个字符串读入程序，首先必须预留储存该字符串的空间，然后用输入函数获取该字符串。
>
> 1. 分配空间
>
>    显式声明，指定数组大小
>
> 2. 输入函数，gets() 
>
> ​	  gets()函数：读取整行输入(直至遇到换行符), 然后储存换行符外的其余字符，并在添加一个'\0字符使其成为一个 C 字符串
>
> ​	示例[10_3_gets.c](src/10_3_gets.c)
>
> ​	  由于gets函数可能输入溢出，C11直接从标准中废除了gets()函数,增加可选扩展gets_s()函数
>
> ​	3.用fgets()函数：
>
> ​		函数的第2个参数指明了读入字符的最大数量。如果该参数的值是n，那么将读入n-1个字符，或者遇到第一个换行符为止。
>
> ​		如果`fgets()`读到一个换行符，会把它储存在字符串中。这点与gets()不同，gets()会丢弃换行符。
>
> ​		第3 个参数指明要读入的文件。如果从键盘输入的数据，以stdin（标准输入，定义在stdio.h中）作为参数
>
> ​    配合`fputs()`函数使用：
>
> ​	fputs()的第2个参数指明它要写入的文件。如果要显示在计算机显示器上，应使用stdout（标准输出）作为该参数。
>
> ​	示例[10_4_fgets_fputs.c](src/10_4_fgets_fputs.c)
>
> 4. gets_s()函数
>
>       示例[10_5_gets_s.c](src/10_5_gets_s.c);

### 3.字符串函数

> 1. `strlen()`用于统计字符串的长度
>
>    示例:[10_6_fit_by_strlen.c](src/10_6_fit_by_strlen.c)
>
> 2. `strcat()`用于拼接字符串, 接收2个参数，把第2个字符串附加到第1个末尾，返回第1个字符串地址
>
>    
>
> 3. `strcmp()` 
>
> 4. `strncmp()` 
>
> 5. `strcpy()` 
>
> 6. `strncpy()` 
>
> 7. `sprintf()` 
>
> 
>
> 
>
> 
